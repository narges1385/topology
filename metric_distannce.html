<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>مقایسه متریک‌ها در فضاهای دوبعدی و سه‌بعدی</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
  <style>
    body { margin: 0; font-family: Tahoma, sans-serif; background: #f0f0f0; overflow: hidden; }
    #container { width: 100vw; height: 100vh; }
    #controls {
      position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
      background: white; padding: 15px 25px; border-radius: 12px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2); z-index: 10; text-align: center;
    }
    select, button { font-size: 16px; padding: 10px 15px; margin: 8px; border-radius: 8px; border: 1px solid #ccc; }
    button { background: #007bff; color: white; cursor: pointer; }
    button:hover { background: #0056b3; }
    #info {
      position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
      background: rgba(0,0,0,0.7); color: white; padding: 10px 20px; border-radius: 8px;
      font-size: 18px;
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="controls">
    <h2>مقایسه متریک‌ها در فضاهای دوبعدی و سه‌بعدی</h2>
    <label>متریک: </label>
    <select id="metricSelect">
      <option value="euclidean">اقلیدسی (کره/دایره)</option>
      <option value="manhattan">منهتن (هشت‌وجهی/الماس)</option>
      <option value="chebyshev">ماکسیمم (مکعب/مربع)</option>
      <option value="discrete">گسسته (نقطه)</option>
    </select>
    <label>بعد: </label>
    <select id="dimensionSelect">
      <option value="3d">سه‌بعدی</option>
      <option value="2d">دو‌بعدی</option>
    </select>
    <button onclick="resetPoints()">شروع دوباره</button>
  </div>
  <div id="info">روی صحنه کلیک کن تا دو نقطه انتخاب کنی (آبی = A، قرمز = B)</div>
  <script>
    // متغیرهای اصلی
    let scene, camera, renderer, controls;
    let points = []; // حداکثر دو نقطه
    let pointMeshes = [];
    let line = null;
    let unitBall = null;
    let metric = 'euclidean';
    let dimension = '3d'; // پیش‌فرض سه‌بعدی

    // راه‌اندازی صحنه
    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xffffff);
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('container').appendChild(renderer.domElement);

      // نور
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7);
      scene.add(light);
      scene.add(new THREE.AmbientLight(0x404040));

      // محورها
      scene.add(new THREE.AxesHelper(5));

      // زمین گرید
      const grid = new THREE.GridHelper(10, 20);
      scene.add(grid);

      // هندلر کلیک
      renderer.domElement.addEventListener('click', onClick);

      // تنظیم دوربین و کنترل‌ها بر اساس بعد
      updateCameraAndControls();

      animate();
    }

    function updateCameraAndControls() {
      if (controls) controls.dispose(); // حذف کنترل قبلی

      if (dimension === '3d') {
        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 5, 8);
      } else { // 2d
        const aspect = window.innerWidth / window.innerHeight;
        const size = 10;
        camera = new THREE.OrthographicCamera(-size * aspect / 2, size * aspect / 2, size / 2, -size / 2, 0.1, 1000);
        camera.position.set(0, 0, 10); // نگاه از بالا به صفحه XY
        camera.lookAt(0, 0, 0);
      }

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.enableZoom = false; // غیرفعال کردن زوم
      controls.enablePan = false; // غیرفعال کردن جابجایی (پن)
      controls.enableRotate = true; // فعال کردن چرخش

      if (dimension === '2d') {
        // در 2D، چرخش را محدود به محور Z کنیم (چرخش در صفحه)
        controls.screenSpacePanning = false;
        controls.minPolarAngle = Math.PI / 2;
        controls.maxPolarAngle = Math.PI / 2;
      }

      updateScene();
    }

    function onClick(event) {
      const rect = renderer.domElement.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
      const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // صفحه XY
      const intersectPoint = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, intersectPoint);
      if (intersectPoint) {
        addPoint(intersectPoint);
      }
    }

    function addPoint(pos) {
      // در 2D، z را همیشه 0 نگه داریم
      if (dimension === '2d') {
        pos.z = 0;
      }

      // حذف نقطه قدیمی اگر دو تا داریم
      if (points.length === 2) {
        points[1] = pos.clone();
        scene.remove(pointMeshes[1]);
      } else {
        points.push(pos.clone());
      }

      // ساخت مش نقطه
      const geometry = new THREE.SphereGeometry(0.15, 32, 32);
      const color = points.length === 1 ? 0x0000ff : 0xff0000; // آبی یا قرمز
      const material = new THREE.MeshPhongMaterial({ color });
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.copy(pos);
      scene.add(sphere);

      if (pointMeshes.length < 2) {
        pointMeshes.push(sphere);
      } else {
        pointMeshes[1] = sphere;
      }

      updateScene();
    }

    function updateScene() {
      // حذف خط و توپ قبلی
      if (line) scene.remove(line);
      if (unitBall) scene.remove(unitBall);

      if (points.length >= 1) {
        drawUnitBall(points[0]);
      }

      if (points.length === 2) {
        drawLineBetweenPoints();
        updateDistanceInfo();
      } else {
        document.getElementById('info').innerHTML = "روی صحنه کلیک کن تا دو نقطه انتخاب کنی (آبی = A، قرمز = B)";
      }
    }

    function drawUnitBall(center) {
      if (unitBall) scene.remove(unitBall);

      let geometry;
      const material = new THREE.MeshPhongMaterial({
        color: 0x00aaff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });

      if (dimension === '3d') {
        if (metric === 'euclidean') {
          geometry = new THREE.SphereGeometry(1, 32, 32);
        } else if (metric === 'manhattan') {
          geometry = new THREE.OctahedronGeometry(1);
        } else if (metric === 'chebyshev') {
          geometry = new THREE.BoxGeometry(2, 2, 2);
        } else if (metric === 'discrete') {
          geometry = new THREE.SphereGeometry(0.1, 16, 16);
          material.color.set(0xff0000);
          material.opacity = 1;
        }
      } else { // 2d
        if (metric === 'euclidean') {
          geometry = new THREE.CircleGeometry(1, 64);
        } else if (metric === 'manhattan') {
          // الماس (دایموند) برای منهتن در 2D
          const shape = new THREE.Shape();
          shape.moveTo(0, 1);
          shape.lineTo(1, 0);
          shape.lineTo(0, -1);
          shape.lineTo(-1, 0);
          shape.lineTo(0, 1);
          geometry = new THREE.ShapeGeometry(shape);
        } else if (metric === 'chebyshev') {
          // مربع برای چبیشف در 2D
          geometry = new THREE.PlaneGeometry(2, 2);
        } else if (metric === 'discrete') {
          geometry = new THREE.CircleGeometry(0.1, 16);
          material.color.set(0xff0000);
          material.opacity = 1;
        }
      }

      unitBall = new THREE.Mesh(geometry, material);
      unitBall.position.copy(center);
      if (dimension === '2d') {
        unitBall.rotation.x = Math.PI / 2; // چرخاندن به صفحه XY برای اشکال 2D
      }
      scene.add(unitBall);
    }

    function drawLineBetweenPoints() {
      if (line) scene.remove(line);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 3 });
      line = new THREE.Line(geometry, material);
      scene.add(line);
    }

    function calculateDistance(p1, p2) {
      const dx = Math.abs(p1.x - p2.x);
      const dy = Math.abs(p1.y - p2.y);
      let dz = Math.abs(p1.z - p2.z);
      if (dimension === '2d') {
        dz = 0; // در 2D، z نادیده گرفته می‌شود
      }

      if (metric === 'euclidean') {
        return Math.sqrt(dx*dx + dy*dy + dz*dz);
      } else if (metric === 'manhattan') {
        return dx + dy + dz;
      } else if (metric === 'chebyshev') {
        return Math.max(dx, dy, dz);
      } else if (metric === 'discrete') {
        return (dx === 0 && dy === 0 && dz === 0) ? 0 : 1;
      }
      return 0;
    }

    function updateDistanceInfo() {
      const d = calculateDistance(points[0], points[1]);
      let name = "";
      if (metric === 'euclidean') name = "اقلیدسی";
      else if (metric === 'manhattan') name = "منهتن";
      else if (metric === 'chebyshev') name = "ماکسیمم (چبیشف)";
      else if (metric === 'discrete') name = "گسسته";

      let dimName = dimension === '3d' ? "سه‌بعدی" : "دو‌بعدی";

      document.getElementById('info').innerHTML = `
        فاصله بین A و B در متریک <strong>${name}</strong> در فضای <strong>${dimName}</strong>: <strong>${d.toFixed(3)}</strong>
      `;
    }

    function resetPoints() {
      points.forEach(p => {
        if (pointMeshes.length > 0) scene.remove(pointMeshes.shift());
      });
      points = [];
      pointMeshes = [];
      if (line) scene.remove(line);
      if (unitBall) scene.remove(unitBall);
      line = null;
      unitBall = null;
      document.getElementById('info').innerHTML = "روی صحنه کلیک کن تا دو نقطه انتخاب کنی (آبی = A، قرمز = B)";
    }

    // تغییر متریک
    document.getElementById('metricSelect').onchange = function(e) {
      metric = e.target.value;
      updateScene();
    };

    // تغییر بعد
    document.getElementById('dimensionSelect').onchange = function(e) {
      dimension = e.target.value;
      // اگر در 2D هستیم، z تمام نقاط را 0 کنیم
      if (dimension === '2d') {
        points.forEach(p => { p.z = 0; });
        pointMeshes.forEach(m => { m.position.z = 0; });
      }
      updateCameraAndControls();
    };

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      const aspect = window.innerWidth / window.innerHeight;
      if (dimension === '3d') {
        camera.aspect = aspect;
        camera.updateProjectionMatrix();
      } else {
        const size = 10;
        camera.left = -size * aspect / 2;
        camera.right = size * aspect / 2;
        camera.top = size / 2;
        camera.bottom = -size / 2;
        camera.updateProjectionMatrix();
      }
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>