<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
  <meta charset="UTF-8">
  <title>فضاهای متریک: مقایسه بصری فاصله‌ها</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.js"></script>
  <style>
    body { font-family: Tahoma, sans-serif; background: #f4f7fa; margin: 0; padding: 20px; text-align: center; }
    h1 { color: #2c3e50; margin-bottom: 10px; }
    .container {
      background: white; border-radius: 16px; box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      padding: 24px; max-width: 960px; margin: 20px auto;
    }
    #canvasContainer {
      width: 800px; height: 600px; margin: 0 auto 20px;
      border-radius: 12px; overflow: hidden; box-shadow: 0 8px 25px rgba(0,0,0,0.12);
    }
    #distance { font-size: 32px; font-weight: bold; color: #e74c3c; margin: 15px 0; }
    .controls { margin: 10px 0; }
    select, button {
      padding: 10px 18px; font-size: 15px; margin: 6px;
      border-radius: 10px; border: 1px solid #ddd; background: white;
    }
    button { background: #3498db; color: white; border: none; cursor: pointer; }
    button:hover { background: #2980b9; }
    .tip { color: #7f8c8d; font-size: 14px; margin-top: 15px; line-height: 1.6; }
  </style>
</head>
<body>
  <h1>مقایسه فاصله‌های متریک در فضای دوبعدی و سه‌بعدی</h1>
  <div class="container">
    <div id="canvasContainer"></div>
    <p id="distance">۰</p>
    <div class="controls">
      <label>نوع فاصله:</label>
      <select id="metricSelect">
        <option value="euclidean">اقلیدسی (Euclidean)</option>
        <option value="manhattan">منهتن (Manhattan)</option>
        <option value="chebyshev">چبیشف (Chebyshev)</option>
        <option value="discrete">گسسته (Discrete)</option>
      </select>
      <button onclick="resetPoints()">ریست نقاط</button>
      <button onclick="switchDimension()">سوییچ به حالت <?= mode === '3D' ? '2D (XZ)' : '3D' ?></button>
    </div>
    <p class="tip" id="tipText"></p>
  </div>

  <script>
    let points = [];
    let metric = 'euclidean';
    let is3D = true;
    const RANGE = 350;
    let p5Instance;

    function recreateCanvas() {
      if (p5Instance) p5Instance.remove();
      p5Instance = new p5(sketch, 'canvasContainer');
    }

    const sketch = function(p) {
      p.setup = function() {
        let c = p.createCanvas(800, 600, is3D ? p.WEBGL : p.P2D);
        c.parent('canvasContainer');
        if (is3D) {
          p.ambientLight(100);
          p.directionalLight(255, 255, 255, 0.5, -0.5, -1);
        }
        updateTip();
      };

      p.draw = function() {
        p.background(240, 245, 250);

        if (is3D) {
          p.orbitControl(1, 1, 0.05); // چرخش و زوم ملایم
          p.rotateY(p.radians(225));
          p.rotateX(p.radians(25));
          drawGrid3D();
          drawAxes3D();
          drawPoints3D();
          drawPath3D();
        } else {
          p.translate(p.width/2, p.height/2);
          drawGrid2D();
          drawAxes2D();
          drawPoints2D();
          drawPath2D();
        }
      };

      p.mousePressed = function() {
        if (p.mouseX < 0 || p.mouseX > p.width || p.mouseY < 0 || p.mouseY > p.height) return;
        if (points.length >= 2) return;

        if (is3D) {
          let x = p.map(p.mouseX, 0, p.width, -RANGE, RANGE);
          let y = p.map(p.mouseY, 0, p.height, -RANGE*0.7, RANGE*0.7);
          let z = p.map(p.mouseX, 0, p.width, -RANGE, RANGE);
          points.push({x, y, z});
        } else {
          let x = p.map(p.mouseX, 0, p.width, -RANGE, RANGE);
          let z = p.map(p.mouseY, 0, p.height, RANGE, -RANGE);
          points.push({x, y: 0, z});
        }
        updateDistance();
      };

      // === 3D ===
      function drawAxes3D() {
        p.strokeWeight(5);
        p.stroke(220, 50, 50); p.line(0,0,0, RANGE,0,0); p.push(); p.translate(RANGE+30,0,0); p.noStroke(); p.fill(220,50,50); p.text('X',0,0); p.pop();
        p.stroke(50, 180, 50); p.line(0,0,0, 0,-RANGE,0); p.push(); p.translate(0,-RANGE-30,0); p.noStroke(); p.fill(50,180,50); p.text('Y',0,0); p.pop();
        p.stroke(50, 50, 220); p.line(0,0,0, 0,0,RANGE); p.push(); p.translate(0,0,RANGE+30); p.noStroke(); p.fill(50,50,220); p.text('Z',0,0); p.pop();
      }

      function drawGrid3D() {
        p.stroke(180); p.strokeWeight(1);
        let step = 50;
        for (let i = -RANGE; i <= RANGE; i += step) {
          p.line(i, 0, -RANGE, i, 0, RANGE);
          p.line(-RANGE, 0, i, RANGE, 0, i);
        }
      }

      function drawPoints3D() {
        p.noStroke();
        if (points[0]) { p.push(); p.fill(231, 76, 60); p.translate(points[0].x, points[0].y, points[0].z); p.sphere(15); p.pop(); }
        if (points[1]) { p.push(); p.fill(41, 128, 185); p.translate(points[1].x, points[1].y, points[1].z); p.sphere(15); p.pop(); }
      }

      function drawPath3D() {
        if (points.length < 2 || metric === 'discrete') return;
        let a = points[0], b = points[1];
        let dx = Math.abs(b.x - a.x), dy = Math.abs(b.y - a.y), dz = Math.abs(b.z - a.z);
        p.strokeWeight(7);
        if (metric === 'euclidean') { p.stroke(155, 89, 182); p.line(a.x,a.y,a.z, b.x,b.y,b.z); }
        else if (metric === 'manhattan') { p.stroke(39, 174, 96); p.line(a.x,a.y,a.z, b.x,a.y,a.z); p.line(b.x,a.y,a.z, b.x,b.y,a.z); p.line(b.x,b.y,a.z, b.x,b.y,b.z); }
        else if (metric === 'chebyshev') {
          p.stroke(243, 156, 18);
          let max = Math.max(dx, dy, dz);
          if (dx === max) p.line(a.x,a.y,a.z, b.x,a.y,a.z);
          else if (dy === max) p.line(a.x,a.y,a.z, a.x,b.y,a.z);
          else p.line(a.x,a.y,a.z, a.x,a.y,b.z);
        }
      }

      // === 2D ===
      function drawAxes2D() {
        p.strokeWeight(5);
        p.stroke(220, 50, 50); p.line(-RANGE, 0, RANGE, 0); p.fill(220,50,50); p.noStroke(); p.text('X', RANGE + 15, 20);
        p.stroke(50, 50, 220); p.line(0, -RANGE, 0, RANGE); p.fill(50,50,220); p.noStroke(); p.text('Z', 15, -RANGE - 10);
      }

      function drawGrid2D() {
        p.stroke(180); p.strokeWeight(1);
        let step = 50;
        for (let i = -RANGE; i <= RANGE; i += step) {
          if (i !== 0) {
            p.line(-RANGE, i, RANGE, i);
            p.line(i, -RANGE, i, RANGE);
          }
        }
      }

      function drawPoints2D() {
        p.noStroke();
        if (points[0]) { p.fill(231, 76, 60); p.ellipse(points[0].x, -points[0].z, 22, 22); p.fill(0); p.text('P1', points[0].x + 10, -points[0].z - 10); }
        if (points[1]) { p.fill(41, 128, 185); p.ellipse(points[1].x, -points[1].z, 22, 22); p.fill(0); p.text('P2', points[1].x + 10, -points[1].z - 10); }
      }

      function drawPath2D() {
        if (points.length < 2 || metric === 'discrete') return;
        let a = points[0], b = points[1];
        let ax = a.x, az = -a.z, bx = b.x, bz = -b.z;
        let dx = Math.abs(b.x - a.x), dz = Math.abs(b.z - a.z);
        p.strokeWeight(7);
        if (metric === 'euclidean') { p.stroke(155, 89, 182); p.line(ax, az, bx, bz); }
        else if (metric === 'manhattan') { p.stroke(39, 174, 96); p.line(ax, az, bx, az); p.line(bx, az, bx, bz); }
        else if (metric === 'chebyshev') {
          p.stroke(243, 156, 18);
          if (dx >= dz) p.line(ax, az, bx, az);
          else p.line(ax, az, ax, bz);
        }
      }
    };

    function updateDistance() {
      if (points.length !== 2) {
        document.getElementById('distance').textContent = '۰';
        return;
      }
      let p1 = points[0], p2 = points[1];
      let dx = Math.abs(p2.x - p1.x);
      let dy = Math.abs(p2.y - p1.y);
      let dz = Math.abs(p2.z - p1.z);
      let dist;
      if (metric === 'euclidean') dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
      else if (metric === 'manhattan') dist = dx + dy + dz;
      else if (metric === 'chebyshev') dist = Math.max(dx, dy, dz);
      else if (metric === 'discrete') dist = (dx===0 && dy===0 && dz===0) ? 0 : 1;
      document.getElementById('distance').textContent = dist.toFixed(2);
    }

    function resetPoints() {
      points = [];
      updateDistance();
    }

    function switchDimension() {
      is3D = !is3D;
      resetPoints();
      recreateCanvas();
      document.querySelector('button[onclick="switchDimension()"]').textContent = 
        is3D ? 'سوییچ به حالت 2D (XZ)' : 'سوییچ به حالت 3D';
      updateTip();
    }

    function updateTip() {
      let tip = document.getElementById('tipText');
      if (is3D) {
        tip.innerHTML = 'کلیک چپ + حرکت ماوس = چرخش<br>اسکرول = زوم<br>کلیک روی صفحه برای انتخاب نقطه';
      } else {
        tip.innerHTML = 'کلیک روی صفحه برای انتخاب دو نقطه روی صفحهٔ XZ (Y=0)<br>مسیر فاصله با رنگ متفاوت نمایش داده می‌شود';
      }
    }

    document.getElementById('metricSelect').addEventListener('change', function(e) {
      metric = e.target.value;
      updateDistance();
    });

    // شروع اولیه
    recreateCanvas();
    document.querySelector('button[onclick="switchDimension()"]').textContent = 'سوییچ به حالت 2D (XZ)';
  </script>
</body>
</html>